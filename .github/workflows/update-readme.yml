name: ü§ñ Actualizar autom√°ticamente el perfil README (P√∫blico)

on:
  schedule:
    - cron: '0 6 * * *'  # Cada d√≠a a las 6:00 AM UTC
  workflow_dispatch:

jobs:
  update-readme:
    runs-on: ubuntu-latest
    name: Actualizar README con la √∫ltima actividad

    steps:
    - name: üöÄ Checkout
      uses: actions/checkout@v4

    - name: üêç Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: üì¶ Install dependencies
      run: pip install requests

    - name: üìä Generar estad√≠sticas de repos p√∫blicos
      run: |
        python << 'EOF'
        import requests
        from datetime import datetime
        from collections import Counter

        username = "masamasa28"
        headers = {'Accept': 'application/vnd.github.v3+json'}

        repos_url = f"https://api.github.com/users/{username}/repos?per_page=100&sort=updated"
        all_repos = requests.get(repos_url, headers=headers).json()

        real_repos = []
        odoo_detected = False
        languages = Counter()

        for repo in all_repos:
            if not repo['fork'] and repo['size'] > 0:
                real_repos.append(repo)
                lang_resp = requests.get(repo['languages_url'], headers=headers)
                if lang_resp.status_code == 200:
                    for lang, count in lang_resp.json().items():
                        languages[lang] += count
                # Detectar Odoo
                contents_resp = requests.get(f"https://api.github.com/repos/{repo['full_name']}/contents", headers=headers)
                if contents_resp.status_code == 200:
                    for file_item in contents_resp.json():
                        if 'name' in file_item:
                            fname = file_item['name'].lower()
                            if any(x in fname for x in ['__manifest__.py','__openerp__.py','odoo.conf','addons']):
                                odoo_detected = True

        tech_badges = {
            'Python':'![Python](https://img.shields.io/badge/Python-3776AB?style=for-the-badge&logo=python&logoColor=white)',
            'JavaScript':'![JavaScript](https://img.shields.io/badge/JavaScript-F7DF1E?style=for-the-badge&logo=javascript&logoColor=black)',
            'PHP':'![PHP](https://img.shields.io/badge/PHP-777BB4?style=for-the-badge&logo=php&logoColor=white)',
            'HTML':'![HTML5](https://img.shields.io/badge/HTML5-E34F26?style=for-the-badge&logo=html5&logoColor=white)',
            'CSS':'![CSS3](https://img.shields.io/badge/CSS3-1572B6?style=for-the-badge&logo=css3&logoColor=white)'
        }

        tech_stack = "### **üõ†Ô∏è Stack Tecnol√≥gico**\n*Actualizado autom√°ticamente*\n\n"
        if odoo_detected:
            tech_stack += "![Odoo](https://img.shields.io/badge/Odoo-714B67?style=for-the-badge&logo=odoo&logoColor=white)\n"
        for lang in languages:
            if lang in tech_badges:
                tech_stack += tech_badges[lang] + "\n"
        tech_stack += f"\n**üìä Repositorios analizados:** {len(real_repos)}\n"

        with open("tech_stack.md","w",encoding="utf-8") as f:
            f.write(tech_stack)

        # Repo analysis
        repo_analysis = "### **üìÇ Repositorios recientes**\n"
        repo_analysis += f"*Actualizado: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')} UTC*\n\n"
        repo_analysis += "| Repositorio | Lenguaje | √öltima Actividad | Tama√±o |\n"
        repo_analysis += "|------------|---------|----------------|--------|\n"
        for repo in real_repos[:6]:
            name = repo['name']
            lang = repo['language'] or 'N/A'
            updated = datetime.strptime(repo['updated_at'],'%Y-%m-%dT%H:%M:%SZ')
            days = (datetime.utcnow() - updated).days
            size = f"{repo['size']} KB" if repo['size']<1024 else f"{repo['size']//1024} MB"
            time_str = "hoy" if days==0 else f"{days}d"
            repo_analysis += f"| [{name}]({repo['html_url']}) | {lang} | {time_str} | {size} |\n"

        with open("repo_analysis.md","w",encoding="utf-8") as f:
            f.write(repo_analysis)

        print("‚úÖ Estad√≠sticas p√∫blicas generadas correctamente")
        EOF

    - name: üìù Actualizar README localmente
      run: |
        python << 'EOF'
        import re
        from datetime import datetime

        with open("README.md","r",encoding="utf-8") as f:
            content = f.read()
        with open("tech_stack.md","r",encoding="utf-8") as f:
            tech_stack = f.read()
        with open("repo_analysis.md","r",encoding="utf-8") as f:
            repo_analysis = f.read()

        content = re.sub(r'<!-- START_SECTION:tech_stack -->.*?<!-- END_SECTION:tech_stack -->',
                         f'<!-- START_SECTION:tech_stack -->\n{tech_stack}<!-- END_SECTION:tech_stack -->', content, flags=re.DOTALL)
        content = re.sub(r'<!-- START_SECTION:repo_analysis -->.*?<!-- END_SECTION:repo_analysis -->',
                         f'<!-- START_SECTION:repo_analysis -->\n{repo_analysis}<!-- END_SECTION:repo_analysis -->', content, flags=re.DOTALL)

        timestamp = datetime.utcnow().strftime('%d/%m/%Y - %H:%M UTC')
        content = re.sub(r'\*√öltima actualizaci√≥n autom√°tica:.*?\*',
                         f'*√öltima actualizaci√≥n autom√°tica: {timestamp}*', content)

        with open("README.md","w",encoding="utf-8") as f:
            f.write(content)
        print("‚úÖ README actualizado localmente")
        EOF

    - name: üßπ Limpiar archivos temporales
      run: rm -f tech_stack.md repo_analysis.md
